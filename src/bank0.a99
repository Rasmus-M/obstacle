***************************************************************
*
* Cartridge bank 0
*
       bank 0

***************************************************************
*
* Main program
*
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
new_game:
       bl   @intro
       bl   @init_game
new_level:
       bl   @init_level
       bl   @main_loop
       mov  @status,r0
       jlt  lost_life
*      Level completed
       li   r0,sp_good_work
       bl   @say_word
       li   r1,txt_level_completed
       bl   @display_message
       li   r2,120
       bl   @wait
       inc  @level
       li   r0,map_width*8+250
       s    @frame,r0
       jlt  new_level
       a    r0,@score
       jmp  new_level
*      Lost life
lost_life:
       dec  @lives
       jne  new_level
*      Game over
       bl   @display_lives
       li   r1,txt_game_over
       bl   @display_message
       li   r1,please_try_again
       bl   @say_phrase
       jmp  new_game

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r14,vdprd                  ; Do not change
       li   r15,vdpwd                  ; Do not change
*      Init speech
       li   r0,speech_status_code
       li   r1,get_speech_status
       li   r2,speech_status_code_end-speech_status_code
       bl   @copy
       seto @speech_on
       clr  @speech_ptr
*      Graphics mode
       bl   @graphics_mode
       .endproc
*// one_time_init

*********************************************************************
*
* Display intro
*
intro:
       .proc
       seto @demo
       clr  @level                     ; Intro is level 0
       bl   @init_level
       li   r0,>0100
       mov  r0,@ball_x
       li   r0,>0180
       mov  r0,@ball_vx
       li   r0,>1000
       mov  r0,@ball_y
*      Scroll intro screen
       li   r0,256
       mov  r0,@frame
       seto @status
       bl   @main_loop
*      Display S'
       li   r0,ptrntb+chr_star_s_apo*8
       li   r1,char_s_apo
       li   r2,8
       bl   @vmbw
       li   r0,3*32+31+nametb
       li   r1,chr_star_s_apo*256
       bl   @vsbw
*      Move ball on
       li   r0,85
       mov  r0,@frame
       clr  @scroll_speed_x
       bl   @main_loop
*      Sprite size 1
       li   r0,>01e0
       bl   @vwtr
       clr  @count
*      Text
       li   r9,43                      ; First wait
intro_1:
       li   r7,txt_title
       li   r8,4
intro_2:
       mov  r9,@frame
       bl   @wait_key
       mov  r0,r0
       jne  intro_3
       mov  r7,r1
       bl   @display_message
       ai   r7,20
       li   r9,192                     ; Subsequent waits
       dec  r8
       jgt  intro_2
       jmp  intro_1
intro_3:
*      Sprite size 2
       li   r0,>01e2
       bl   @vwtr
*      End demo
       clr @demo
       .endproc
*// intro

*********************************************************************
*
* Wait until fire or timeout, also handles settings.
*
* @frame: Number of frames to wait
*
* Modifies r0-r6
*
wait_key:
       .proc
wait_key_1:
       bl   @vsync
       li   r13,module_player#
       bl   @bank_1_exec
       bl   @check_quit
       li   r0,JOY_FI
       bl   @check_key
       jne  wait_key_5
       li   r0,KEY_SP
       bl   @check_key
       jne  wait_key_6
*      Speech on/off
       li   r0,KEY_S
       bl   @check_key
       jeq  wait_key_4
       mov  @speech_on,r0
       jne  wait_key_2
       seto @speech_on
       li   r0,sp_on
       bl   @say_word
       li   r7,txt_speech_on
       jmp  wait_key_3
wait_key_2:
       clr  @speech_on
       li   r7,txt_speech_off
wait_key_3:
       li   r0,KEY_S
       bl   @check_key
       jne  wait_key_3
       seto r8                         ; Frames left
       clr  r0
       jmp  wait_key_8
wait_key_4:
       bl   @sparkles
*      Loop
       dec  @frame
       jne  wait_key_1
       clr  r0
       jmp  wait_key_8
wait_key_5:
       li   r0,keys_joystick
       jmp  wait_key_7
wait_key_6:
       li   r0,keys_keyboard
wait_key_7:
       mov  r0,@controls
       seto r0                         ; Done
wait_key_8:
       .endproc
*// wait_key

*********************************************************************
*
* Display sparkles
*
sparkles:
       .proc
       li   r0,spratb
       bl   @vwad
       mov  @enemy_y,r4
       mov  @enemy_x,r5
sparkles_0:
       clr  r2
sparkles_1:
*      Rnd 1
       mov  r4,r0
       ai   r0,56241
       li   r1,39723
       mpy  r1,r0
       mov  r1,r4
*      Rnd 2
       mov  r5,r0
       ai   r0,13957
       li   r1,28577
       mpy  r1,r0
       mov  r1,r5
*      Save seeds
       ci   r2,3
       jne  sparkles_2
       mov  @count,r0
       andi r0,>001f
       jne  sparkles_2
       mov  r4,@enemy_y
       mov  r5,@enemy_x
*      Y and X
sparkles_2:
       mov  r4,r0
       andi r0,>7f
       ai   r0,>08
       swpb r0
       mov  r5,r1
       andi r1,>ff
       soc  r1,r0
*      Pattern and color
       mov  @count,r1
       a    r2,r1
       andi r1,>001c
       srl  r1,2
       andi r1,7
       ai   r1,>d8
       swpb r1
       ori  r1,>0f
*      Write attributes
       movb r0,*r15
       movb @r0lb,*r15
       movb r1,*r15
       movb @r1lb,*r15
*      Loop
       inc  r2
       ci   r2,8
       jne  sparkles_1
       li   r1,>d000
       movb r1,*r15
       inc  @count
       .endproc
*// Sparkles

*********************************************************************
*
* Wait for a number of frames
*
* r2: number of frames to wait
*
wait:
       .proc
       mov  r2,@frame
wait_1:
       bl   @vsync
       li   r13,module_player#
       bl   @bank_1_exec
       bl   @check_quit
       dec  @frame
       jne  wait_1
       .endproc
*// wait

***************************************************************
*
* Initialize game
*
init_game:
       .proc
       li   r0,start_level
       mov  r0,@level
       clr  @score
       seto @disp_score
       li   r0,n_lives
       mov  r0,@lives
       li   r1,three_two_one_go
       bl   @say_phrase
       .endproc
*// init_game

***************************************************************
*
* Initialize level
*
init_level:
       .proc
*      Screen off
       li   r0,>01a2
       bl   @vwtr
*      Mute sound
       bl   @mute_sound
*      Scratch pad variables
       li   r0,clear_start
       li   r2,clear_end-clear_start
       bl   @clear
*      Modified level
       mov  @level,r1
       jeq  init_level_1
       dec  r1
       andi r1,n_levels-1
       inc  r1
init_level_1:
       mov  r1,@mod_level
*      Level orientation
       clr  @vertical
       movb @level_vertical(r1),r0
       jeq  init_level_4
       seto @vertical
init_level_4:
*      Enemy list pointer
       sla  r1,1
       mov  @enemy_lists(r1),@enemy_list_ptr
*      Ball variables
       li   r0,ball_init_data
       mov  *r0+,@ball_x
       mov  *r0+,@ball_y
       mov  *r0+,@ball_ay
       mov  *r0+,@ball_pattern_color
*      Scroll speed
       clr  r0
       clr  r1
       abs  @vertical
       jne  init_level_7
       li   r0,scroll_speed_normal
init_level_7:
       mov  r0,@scroll_speed_x
       mov  r1,@scroll_speed_y
*      Setup display
       li   r13,copy_map_to_vdp#
       bl   @bank_1_exec
       bl   @read_grom_chars
       abs  @vertical
       jne  init_level_5
*      Horizontal
       bl   @scroll_patterns
       bl   @update_full_name_table
       jmp  init_level_6
init_level_5:
*      Vertical
       bl   @scroll_patterns_vert
       bl   @update_full_name_table_vert
init_level_6:
       bl   @scroll_star_patterns
       bl   @set_colors
*      Text
       mov  @level,r0
       jeq  init_level_8
       li   r0,23*32+1
       li   r1,txt_stats
       bl   @display_text
       bl   @display_level
       bl   @display_lives
       mov  @mod_level,r1
       sla  r1,1
       mov  @level_names(r1),r1
       bl   @display_message
init_level_8:
*      Sprite patterns
       bl   @upload_sprite_patterns
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Music
       mov  @level,r0
       andi r0,1
       jne  init_level_2
       li   r0,obstacles_module#
       jmp  init_level_3
init_level_2:
       li   r0,bipbop_module#
init_level_3:
       li   r13,play_module#
       bl   @bank_1_exec
*      Screen on
       li   r0,nametb/>400+>0200
       bl   @vwtr
       li   r0,ptrntb/>800+>0400
       bl   @vwtr
       li   r0,>01e2
       bl   @vwtr
       .endproc
ball_init_data:
       data >3000,>8000,>0018,>800f
*// init_level

*********************************************************************
*
* Main game loop
*
main_loop:
       .proc
main_loop_1:
       bl   @vsync
       bl   @update_vdp_regs
       bl   @upload_sprites
       bl   @move_ball
       bl   @move_other_sprites
       bl   @check_enemy_collision
       bl   @update_partial_name_table
       bl   @user_input
       bl   @display_score
       bl   @check_quit
       li   r13,module_player#
       bl   @bank_1_exec
       bl   @speak
       bl   @scroll
       mov  @status,r0
       jlt  main_loop_2
       jgt  main_loop_3
       inc  @frame
       jmp  main_loop_1
main_loop_2:
       dec  @frame
       jgt  main_loop_1
main_loop_3:
       .endproc
*// main_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

***************************************************************
*
* Update VDP registers
*
update_vdp_regs:
       .proc
*      Set pattern table
       mov  @scroll_offset_pixels,r0
       andi r0,>0007
       ori  r0,>0400
       bl   @vwtr
*      Set name table
       mov  @scroll_offset_pixels,r0
       andi r0,>0008
       srl  r0,2
       inc  r0
       ori  r0,>0200
       bl   @vwtr
       .endproc
*// update_vdp_regs

***************************************************************
*
* Upload sprites to VDP
*
upload_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
*      Ball
       mov  @ball_y,r0
       ai   r0,->0100
       mov  @ball_x,r1
       mov  @ball_pattern_color,r2
       bl   @upload_sprite
       ai   r2,>04f8
       bl   @upload_sprite
*      Points
       mov  @points_sprite_y,r0
       jeq  upload_sprites_1
       ai   r0,->0100
       mov  @points_sprite_x,r1
       mov  @points_sprite_pattern_color,r2
       bl   @upload_sprite
upload_sprites_1:
*      Enemy
       mov  @enemy_y,r0
       jeq  upload_sprites_2
       ai   r0,->0100
       mov  @enemy_x,r1
       li   r2,>800f
       bl   @upload_sprite
       ai   r2,>04fe
       bl   @upload_sprite
*      End marker
upload_sprites_2:
       li   r1,>d000
       movb r1,*r15
       .endproc
upload_sprite:
       movb r0,*r15                    ; y
       movb r1,*r15                    ; x
       movb r2,*r15                    ; Pattern
       movb @r2lb,*r15                 ; Color
       rt
*// upload_sprites

***************************************************************
*
* Move ball
*
move_ball:
       .proc
       abs  @demo
       jeq  move_ball_16
       b    @move_ball_14
**
*      X
*      Check x velocity
move_ball_16:
       mov  @ball_x,r1
       mov  @ball_vx,r0
       s    @scroll_speed_x,r0
       jlt  move_ball_1
       ci   r1,>e800
       jl   move_ball_0
move_ball_3:
       mov  @scroll_speed_x,@ball_vx     ;  Stop if right edge is reached
*      Check char to the right of ball
move_ball_0:
       li   r0,>1000
       li   r1,>0800
       bl   @get_map_char_ball
       jeq  move_ball_2
       bl   @check_coinc_right
       jmp  move_ball_2
*      Check char to the left of ball
move_ball_1:
       a    r0,r1
       ci   r1,>fc00                   ; Check if left edge is reached
       jhe   move_ball_3
       li   r0,->0100
       li   r1,>0000
       bl   @get_map_char_ball
       jeq  move_ball_2
       bl   @check_coinc_left
*      Move x
move_ball_2:
       mov  @ball_vx,r0
       s    @scroll_speed_x,r0           ; Movement from scrolling
       a    r0,@ball_x
*      Animate
       mov  @ball_vx,r0
       jeq  move_ball_15               ; Only if moving x
       mov  @ball_vy,r0
       jne  move_ball_15               ; Not if moving y
       mov  @ball_animation_ptr,r0
       jne  move_ball_15
       li   r0,animation_roll
       mov  r0,@ball_animation_ptr
move_ball_15:
**
*      Y
       mov  @ball_y,r0
       ci   r0,(screen_height-2)*8*256
       jhe  move_ball_17
       a    @scroll_speed_y,@ball_y
       jmp  move_ball_18
move_ball_17:
       bl   @die
*      Check for rebounce
move_ball_18:
       mov  @ball_rebounce,r0
       jne  move_ball_12
*      Accelerate
       a    @ball_ay,@ball_vy
*      Check y velocity
       mov  @ball_vy,r0
       jeq  move_ball_4
       jlt  move_ball_6
*      Moving down
*      Check char below ball
move_ball_4:
       li   r0,>0800
       li   r1,>1000
       bl   @get_map_char_ball
       jeq  move_ball_7
       bl   @check_coinc_bottom
       jmp  move_ball_7
*      Moving up
move_ball_6:
       ci   r0,->0080
       jlt  move_ball_13
       li   r0,>8000
       movb r0,@ball_pattern_color
*      Check char above ball
move_ball_13:
       li   r0,>0a00
       li   r1,->0100
       bl   @get_map_char_ball
       jeq  move_ball_7
       bl   @check_coinc_top
*      Move y
move_ball_7:
       a    @ball_vy,@ball_y
       jmp  move_ball_5
*      Rebounce
move_ball_12
       mov  r0,@ball_vy
       clr  @ball_rebounce
*      Animate
move_ball_5:
       mov  @ball_animation_ptr,r0
       jeq  move_ball_10
move_ball_8:
       mov  @ball_animation_count,r1
       jne  move_ball_11
       movb *r0+,@ball_pattern_color
       movb *r0+,@ball_animation_count+1
       jeq  move_ball_9
       mov  r0,@ball_animation_ptr
       jmp  move_ball_11
move_ball_9:
       clr  @ball_animation_ptr
       jmp  move_ball_10
move_ball_11:
       dec  @ball_animation_count
       jmp  move_ball_10
*      Demo
move_ball_14:
       a    @ball_vx,@ball_x
       s    @scroll_speed_x,@ball_x
       a    @ball_ay,@ball_vy
       a    @ball_vy,@ball_y
       mov  @ball_y,r0
       li   r1,16*8*256
       c    r0,r1
       jle  move_ball_10
       mov  r1,@ball_y
       neg  @ball_vy
       li   r0,>0040
       a    r0,@ball_vy
       bl   @play_jump
move_ball_10:
       .endproc
*// move_ball

***************************************************************
*
* Move other sprites than the ball
*
move_other_sprites:
       .proc
*      Points sprite
       mov  @points_sprite_y,r0
       jeq  move_other_sprites_2
       ci   r0,>1000
       jl   move_other_sprites_1
       ai   r0,->0100
       mov  r0,@points_sprite_y
       mov  @points_sprite_x,r0
       ci   r0,>0200
       jl   move_other_sprites_1
       s    @scroll_speed_x,r0
       mov  r0,@points_sprite_x
       jmp  move_other_sprites_2
move_other_sprites_1:
       clr  @points_sprite_y
move_other_sprites_2:
*      Enemy
       mov  @enemy_y,r0
       jeq  move_other_sprites_4
       a    @enemy_vx,@enemy_x
       a    @ball_ay,@enemy_vy
       mov  @enemy_x,r0
       ci   r0,>0100
       jh   move_other_sprites_6
       clr  @enemy_y
       jmp  move_other_sprites_5
move_other_sprites_6:
       mov  @enemy_vy,r0
       jlt  move_other_sprites_3
       mov  @enemy_x,r0
       ai   r0,>0800
       mov  @enemy_y,r1
       ai   r1,>1000
       bl   @get_map_char
       coc  @char_block_top,r1
       jne  move_other_sprites_3
       mov  @enemy_vy,r1
       ai   r1,->0050
       neg  r1
       mov  r1,@enemy_vy
move_other_sprites_3:
       a    @enemy_vy,@enemy_y
       jmp  move_other_sprites_5
move_other_sprites_4:
       mov  @enemy_list_ptr,r0
       c    @scroll_offset_pixels,*r0+
       jne  move_other_sprites_5
       mov  r0,@enemy_list_ptr
       li   r0,>ff00
       mov  r0,@enemy_x
       li   r1,>3000
       mov  r1,@enemy_y
       li   r0,>fe80
       mov  r0,@enemy_vx
       li   r0,sp_uhoh
       bl   @say_word
move_other_sprites_5:
       .endproc
*// move_other_sprites<

***************************************************************
*
* Check for collision with enemy
*
check_enemy_collision:
       .proc
       mov  @vdp_status,r0
       andi r0,>2000
       jeq  check_enemy_collision_1
       mov  @enemy_y,r0
       jeq  check_enemy_collision_1
       s    @ball_y,r0
       abs  r0
       ci   r0,>1000
       jgt  check_enemy_collision_1
       mov  @enemy_x,r0
       s    @ball_x,r0
       abs  r0
       ci   r0,>1000
       jgt  check_enemy_collision_1
       bl   @die
check_enemy_collision_1:
       .endproc
*// check_enemy_collision

***************************************************************
*
* Update 1/8 name table
*
update_partial_name_table:
       .proc
       mov  @scroll_offset,r6
       abs  @vertical
       jne  update_partial_name_table_4
       srl  r6,3                       ; Number of half pixels scrolled
       mov  @scroll_speed_x,r8         ; Scrolling speed
       swpb r8
       andi r8,>0003                   ; 0, 1 or 2
*      Ceiling and floor
       mov  r6,r1
       andi r1,>001f
       sla  r1,1
       mov  @floor_ceil_table(r1),r0   ; Get destination address
       bl   @vwad
       mov  r6,r1
       andi r1,>000c                   ; Choose between celing,floor,top,bottom
       srl  r1,1
       mov  @ceiling(r1),r3            ; Get character pair
       mov  r6,r1
       andi r1,>0010
       jne  update_partial_name_table_0
       swpb r3                         ; Swap characters if we start with an odd map row
update_partial_name_table_0:
       li   r2,2
       mov  r8,r0                      ; Speed
       jeq  update_partial_name_table_3
       sla  r2,0
update_partial_name_table_3:
       movb r3,r0
       swpb r3
       movb r3,r1
update_partial_name_table_1:
       movb r0,*r15
       movb r1,*r15
       movb r0,*r15
       movb r1,*r15
       dec  r2
       jne  update_partial_name_table_1
*      Middle rows
       andi r6,>000f
       inct r6                         ; Adjust for ceiling
       li   r7,1
       mov  r8,r0                      ; Speed
       jeq  update_partial_name_table_5
       sla  r7,0
       jmp  update_partial_name_table_5
*      Vertical
update_partial_name_table_4
       srl  r6,2                       ; Number of quarter pixels scrolled
       andi r6,>001f                   ; Display 2 rows for the first 10 frames
       ci   r6,screen_height
       jhe  update_partial_name_table_6
       li   r7,1
update_partial_name_table_5
       bl   @copy_map_rows_from_vdp
update_partial_name_table_6
       .endproc
*// update_partial_name_table

***************************************************************
*
* Read user input
*
user_input:
       .proc
       mov  @status,r0
       jlt  user_input_5
       mov  @ball_vy,r0
       jne  user_input_4
       mov  @controls,r6
*      Joystick
       mov  *r6+,r0
       bl   @check_key                 ; Jump
       jeq  user_input_1
       bl   @jump
user_input_1:
       abs  @vertical
       jne  user_input_8
*      Horizontal
       mov  @scroll_speed_x,r1           ; Default speed
       mov  *r6+,r0
       bl   @check_key                 ; Left
       jeq  user_input_2
       li   r1,->0040
       jmp  user_input_3
user_input_2:
       mov  *r6,r0
       bl   @check_key                 ; Right
       jeq  user_input_3
       ai   r1,>0080
       jmp  user_input_3
*      Vertical
user_input_8
       clr  r1
       mov  *r6+,r0
       bl   @check_key                 ; Left
       jeq  user_input_9
       li   r1,->0100
       jmp  user_input_3
user_input_9:
       mov  *r6,r0
       bl   @check_key                 ; Right
       jeq  user_input_3
       li   r1,>0100
*      Set velocity
user_input_3:
       mov  r1,@ball_vx
       mov  r1,@ball_vx_last
       jmp  user_input_7
user_input_4:
       mov  @ball_vx_last,@ball_vx
       jmp  user_input_7
user_input_5:
       abs  @demo
       jeq  user_input_7
       li   r0,JOY_FI
       bl   @check_key
       jne  user_input_6
       li   r0,KEY_SP
       bl   @check_key
       jeq  user_input_7
user_input_6:
       clr  @frame
user_input_7:
       .endproc
*// user_input

***************************************************************
*
* Display score
*
display_score:
       .proc
       c    @score,@disp_score
       jeq  display_score_1
       li   r0,32*23+8
       mov  @score,r1
       li   r2,5
       bl   @display_decimal
       mov  @score,@disp_score
display_score_1:
       .endproc
*// display_score

***************************************************************
*
* Display level
*
display_level:
       .proc
       li   r0,32*23+20
       mov  @level,r1
       li   r2,2
       bl   @display_decimal
       .endproc
*// display_level

***************************************************************
*
* Display lives
*
display_lives:
       .proc
       li   r0,32*23+29
       mov  @lives,r1
       li   r2,2
       bl   @display_decimal
       .endproc
*// display_lives

*********************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       rt
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

***************************************************************
*
* Update scrolling variables
*
scroll:
       mov  @scroll_speed_request,r1
       jeq  scroll_1
       mov  @scroll_offset,r0
       andi r0,>007f
       jne  scroll_1
       mov  r1,@scroll_speed_x
       clr  @scroll_speed_request
scroll_1:
       mov  @scroll_offset,r0
       abs  @vertical
       jne  scroll_3
       mov  @scroll_speed_x,r1
       jmp  scroll_4
scroll_3:
       clr  r1
       mov  @frame,r2
       ci   r2,120
       jne  scroll_5
       li   r1,scroll_speed_slower
       mov  r1,@scroll_speed_y
       jmp  scroll_4
scroll_5:
       mov  @scroll_speed_y,r1
scroll_4:
       sra  r1,4
       a    r1,r0
       mov  r0,@scroll_offset
       srl  r0,4
       mov  r0,@scroll_offset_pixels
       abs  @vertical
       jne  scroll_6
*      H
       ci   r0,map_width*8
       jhe  scroll_7
       jmp  scroll_2
scroll_6:
*      V
       ci   r0,(map_height_h-screen_height)*8
       jl   scroll_2
       clr  @scroll_speed_y
       mov  @ball_y,r0
       ci   r0,>3000
       jh   scroll_2
scroll_7:
       inc  @status
scroll_2:
       rt
*// scroll

***************************************************************
*
* Copy map rows from VDP RAM
*
* r6: Start screen row number to copy
* r7: Number of rows to copy
*
copy_map_rows_from_vdp:
       .proc
       mov  r6,r8                      ; Save the start row
*      Dest
       mov  @scroll_offset_pixels,r1   ; Calculate current name table address
       inv  r1
       andi r1,>0008
       sla  r1,8
       ai   r1,nametb
       mov  r6,r0                      ; Row offset
       sla  r0,5                       ; * 32
       a    r0,r1
*      Check if vertical
       abs  @vertical
       jne  copy_map_rows_from_vdp_4
*      Source
       mov  @scroll_offset_pixels,r5
       srl  r5,3                       ; Column offset
       inc  r5                         ; Plus one
       andi r5,map_width-1             ; Wrap at 256 columns
       dect r6                         ; Compensate for ceiling
       sla  r6,1                       ; Lookup table address
       ai   r6,map_row_table
copy_map_rows_from_vdp_1:
;       abs  @vertical                 ; Only needed if more than one row when vertical
;       jne  copy_map_rows_from_vdp_4
       mov  *r6+,r0                    ; Row start
       a    r5,r0                      ; Add column offset
       ci   r5,map_width-screen_width
       jh   copy_map_rows_from_vdp_2
*      Fast, non-wrapping
       bl   @copy_row_to_buffer
       jmp  copy_map_rows_from_vdp_3
*      Slow, wrapping
copy_map_rows_from_vdp_2:
       bl   @vrad
       li   r4,buffer
       li   r2,map_width
       s    r5,r2
copy_map_rows_from_vdp_5:              ; Copy 1st part
       movb *r14,*r4+
       dec  r2
       jne  copy_map_rows_from_vdp_5
       mov  r5,r2
       ai   r2,-(map_width-screen_width)
       dect r6
       mov  *r6+,r0                    ; From beginning
       bl   @vrad
copy_map_rows_from_vdp_6:              ; Copy 2nd part
       movb *r14,*r4+
       dec  r2
       jne  copy_map_rows_from_vdp_6
*      Draw stars
copy_map_rows_from_vdp_3:
       clr  r9                         ; Offset
       bl   @draw_stars
       jmp  copy_map_rows_from_vdp_7
*      Vertical
copy_map_rows_from_vdp_4:
       mov  @scroll_offset_pixels,r5
       srl  r5,3                       ; Row offset
       neg  r5
       ai   r5,map_height_h-screen_height    ; Row number
       dec  r5                         ; Minus one
       a    r8,r5                      ; Add row number
       sla  r5,5                       ; Char offset
       mov  r5,r0
       andi r0,>03e0
       sla  r5,1
       andi r5,>0800
       ai   r5,vmap0
       a    r5,r0
       bl   @copy_row_to_buffer
       clr  r9                         ; Offset
       bl   @draw_stars_vert
*      Copy buffer back
copy_map_rows_from_vdp_7:
       bl   @copy_row_to_vdp
*      Next row
       ai   r1,screen_width
       inc  r8                         ; Row number
       dec  r7
       jne  copy_map_rows_from_vdp_1
       .endproc
*// copy_map_rows_from_vdp

***************************************************************
*
* Update full name table
*
update_full_name_table:
       .proc
*      Ceiling and floor
       li   r0,nametb
       li   r3,ceiling
       li   r4,2
update_full_name_table_0:
       bl   @vwad
       mov  *r3+,r1
       bl   @update_full_name_table_2
       mov  *r3+,r1
       bl   @update_full_name_table_2
       ai   r0,>0240
       dec  r4
       jne  update_full_name_table_0
*      Dest
       li   r1,nametb+>40
*      Source
       mov  @scroll_offset_pixels,r5
       srl  r5,3                       ; Column offset
       li   r6,map_row_table
*      Copy
       li   r8,2
update_full_name_table_1:
       mov  *r6+,r0                    ; Row start
       a    r5,r0                      ; Add column offset
       bl   @copy_row_to_buffer
       seto r9                         ; Offset
       bl   @draw_stars
       bl   @copy_row_to_vdp
       ai   r1,screen_width
       inc  r8
       ci   r8,screen_height-2
       jlt  update_full_name_table_1
       .endproc
**
*      Copy a row of ceiling/floor
update_full_name_table_2:
       li   r2,16
update_full_name_table_3:
       movb r1,*r15
       movb @r1lb,*r15
       dec  r2
       jne  update_full_name_table_3
       rt
*// update_full_name_table

***************************************************************
*
* Check collision to the right of ball
*
* r0: VDP address of collision char
* r1: Collision char properties
*
check_coinc_right:
       .proc
       coc  @char_deadly,r1
       jeq  check_coinc_right_1
       coc  @char_collectable,r1
       jeq  check_coinc_right_2
       coc  @char_slow_speed,r1
       jeq  check_coinc_right_4
       coc  @char_normal_speed,r1
       jeq  check_coinc_right_5
       coc  @char_block_left,r1
       jne  check_coinc_right_3
*      Collision with blocker
       clr  @ball_vx
       mov  @ball_x,r0
       andi r0,>fe00                   ; Die at x=0 or x=1
       jne  check_coinc_right_3
*      Collision with deadly
check_coinc_right_1:
       bl   @die
       jmp  check_coinc_right_3
*      Collision with collectable
check_coinc_right_2:
       bl   @collect_item
       jmp  check_coinc_right_3
*      Collision with slow
check_coinc_right_4:
       bl   @slow_speed
       jmp  check_coinc_right_3
*      Collision with normal
check_coinc_right_5:
       bl   @normal_speed
check_coinc_right_3:
       .endproc
*// check_coinc_right

***************************************************************
*
* Check collision to the left of ball
*
* r0: VDP address of collision char
* r1: Collision char properties
*
check_coinc_left:
       .proc
       coc  @char_deadly,r1
       jeq  check_coinc_left_1
       coc  @char_collectable,r1
       jeq  check_coinc_left_2
       coc  @char_block_right,r1
       jne  check_coinc_left_3
*      Collision with blocker
       clr  @ball_vx
       jmp  check_coinc_left_3
*      Collision with deadly
check_coinc_left_1:
       bl   @die
       jmp  check_coinc_left_3
*      Collision with collectable
check_coinc_left_2:
       bl   @collect_item
check_coinc_left_3:
       .endproc
*// check_coinc_left

***************************************************************
*
* Check collision below the ball
*
* r0: VDP address of collision char
* r1: Collision char properties
*
check_coinc_bottom:
       .proc
       coc  @char_deadly,r1
       jeq  check_coinc_bottom_1
       coc  @char_collectable,r1
       jeq  check_coinc_bottom_2
       coc  @char_long_jump,r1
       jeq  check_coinc_bottom_7
       coc  @char_block_top,r1
       jne  check_coinc_bottom_3
*      Collision with blocker
       mov  @ball_vy,r0
       ci   r0,>0300
       jlt  check_coinc_bottom_4
       li   r0,->0100
       mov  r0,@ball_rebounce          ; Rebounce
       jmp  check_coinc_bottom_5
check_coinc_bottom_4:
       ci   r0,>0020
       jlt  check_coinc_bottom_6
check_coinc_bottom_5:
       abs  @vertical
       jne  check_coinc_bottom_8
       mov  @ball_y,r0                 ; Align to meta tile
       andi r0,>f000
       mov  r0,@ball_y
check_coinc_bottom_8:
       li   r0,>800f
       mov  r0,@ball_pattern_color
       mov  @ball_animation_ptr,r0
       jne  check_coinc_bottom_6
       li   r0,animation_land          ; Animate
       mov  r0,@ball_animation_ptr
check_coinc_bottom_6:
       clr  @ball_vy                   ; Stop movement
       jmp  check_coinc_bottom_3
*      Collision with deadly
check_coinc_bottom_1:
       bl   @die
       jmp  check_coinc_left_3
*      Collision with collectable
check_coinc_bottom_2:
       bl   @collect_item
       jmp  check_coinc_left_3
*      Collision with spring
check_coinc_bottom_7:
       bl   @long_jump
check_coinc_bottom_3:
       .endproc
*// check_coinc_bottom

***************************************************************
*
* Check collision above the ball
*
* r0: VDP address of collision char
* r1: Collision char properties
*
check_coinc_top:
       .proc
       coc  @char_deadly,r1
       jeq  check_coinc_top_1
       coc  @char_collectable,r1
       jeq  check_coinc_top_2
       coc  @char_block_bottom,r1
       jne  check_coinc_top_3
*      Collision with blocker
       seto  @ball_vy
       jmp  check_coinc_left_3
*      Collision with deadly
check_coinc_top_1:
       bl   @die
       jmp  check_coinc_left_3
*      Collision with collectable
check_coinc_top_2:
       bl   @collect_item
check_coinc_top_3:
       .endproc
*// check_coinc_top

***************************************************************
*
* Die
*
die:
       .proc
       mov  @status,r0
       jlt  die_3
       seto @status
       li   r2,animation_die           ; Animate
       mov  r2,@ball_animation_ptr
       clr  @scroll_speed_x
       clr  @ball_vx
       clr  @ball_vy
       bl   @play_die
       mov  @frame,r0
       andi r0,3
       jeq  die_1
       li   r1,oh_no
       jmp  die_2
die_1:
       li   r1,nice_try_partner
die_2:
       bl   @say_phrase
       li   r0,120
       mov  r0,@frame
die_3:
       .endproc
*// die

***************************************************************
*
* Init jump
*
jump:
       .proc
       li   r0,->02c0
       mov  r0,@ball_vy
       li   r0,>880f
       mov  r0,@ball_pattern_color
       clr  @ball_rebounce
       clr  @ball_animation_ptr
       bl   @play_jump
       .endproc
*// jump

***************************************************************
*
* Init long jump
*
long_jump:
       .proc
       li   r1,spring_collapsed
       bl   @replace_meta_tile
       li   r0,->0400
       mov  r0,@ball_vy
       li   r0,>880e
       mov  r0,@ball_pattern_color
       clr  @ball_rebounce
       bl   @play_long_jump
       li   r1,good_move
       bl   @say_phrase
       .endproc
*// long_jump

***************************************************************
*
* Collect an item
*
* r0: VDP address of a character in the metatile
* r1: Tile properties
*
collect_item:
       .proc
       bl   @remove_meta_tile
       coc  @char_extra_life,r1
       jne  collect_item_3
       inc  @lives
       bl   @display_lives
       jmp  collect_item_5
collect_item_3:
       coc  @char_power_up,r1
       jne collect_item_4
       bl   @fast_speed
       jmp  collect_item_5
collect_item_4:
       mov  @ball_y,r0
       ai   r0,->1000
       jlt  collect_item_6
       mov  r0,@points_sprite_y
       mov  @ball_x,r0
       mov  @ball_vx,r1
       jeq  collect_item_7
       jlt  collect_item_8
       li   r1,>1000
       jmp  collect_item_7
collect_item_8:
       li   r1,->1000
collect_item_7:
       a    r1,r0
       mov  r0,@points_sprite_x
collect_item_6:
       mov  @scroll_speed_x,r0
       ci   r0,scroll_speed_slow
       jeq  collect_item_1
       li   r0,sprite_100_pt
       li   r1,100
       jmp  collect_item_2
collect_item_1:
       li   r0,sprite_50_pt
       li   r1,50
collect_item_2:
       mov  *r0,@points_sprite_pattern_color
       a    r1,@score
collect_item_5:
       bl   @play_star
       .endproc
*// collect_item

***************************************************************
*
* Set scrolling to slow
*
slow_speed:
       .proc
       mov  @scroll_speed_x,r0
       ci   r0,scroll_speed_slow
       jeq  slow_speed_1
       mov  @scroll_speed_request,r0
       jne  slow_speed_1
       li   r0,scroll_speed_slow
       mov  r0,@scroll_speed_request
       bl   @play_slow
       li   r1,hurry_up
       bl   @say_phrase
slow_speed_1:
       .endproc
*// slow_speed

***************************************************************
*
* Set scrolling to normal
*
normal_speed:
       .proc
       mov  @scroll_speed_x,r0
       ci   r0,scroll_speed_normal
       jeq  normal_speed_1
       mov  @scroll_speed_request,r0
       jne  normal_speed_1
       li   r0,scroll_speed_normal
       mov  r0,@scroll_speed_request
       bl   @play_normal
       li   r1,back_again
       bl   @say_phrase
normal_speed_1:
       .endproc
*// normal_speed

***************************************************************
*
* Set scrolling to fast
*
fast_speed:
       .proc
       mov  @scroll_speed_x,r0
       ci   r0,scroll_speed_fast
       jeq  fast_speed_1
       mov  @scroll_speed_request,r0
       jne  fast_speed_1
       li   r0,scroll_speed_fast
       mov  r0,@scroll_speed_request
       bl   @play_long_jump
       li   r1,no_more_stop
       bl   @say_phrase
fast_speed_1:
       .endproc
*// fast_speed

***************************************************************
*
* Get map char relative to ball
*
* r0: x offset in MSB
* r1: y offset in MSB
*
* Call get_map_char to specify the absolute position
* in r0 and r1 instead.
*
* On return:
* r0 contains the VDP address of the character
* r1 contains the properties of the character
*
get_map_char_ball:
       a    @ball_x,r0                 ; Add x to offset
       a    @ball_y,r1                 ; Add y to offset
get_map_char:
       abs  @vertical
       jne  get_map_char_vert
       srl  r1,11                      ; Y to chars
       ci   r1,2                       ; Above map?
       jhe  get_map_char_1
       clr  r0                         ; No VDP address
       clr  r1                         ; Space properties
       rt
get_map_char_1:
       dect r1                         ; Adjust for ceiling
       ci   r1,map_height              ; Below map?
       jl   get_map_char_2
       clr  r0                         ; No VDP address
       li   r1,:0000000000001111       ; Floor properties
       rt
get_map_char_2:
       srl  r0,8                       ; To pixels
       a    @scroll_offset_pixels,r0   ; Add scroll offset
       srl  r0,3                       ; To chars
       andi r0,>00ff                   ; Wrap around
       sla  r1,1                       ; To word
       a    @map_row_table(r1),r0      ; Add row offset
       li   r2,TCHARS
       jmp get_map_char_3
get_map_char_vert:
       srl  r1,8                       ; Y to pixels
       ci   r1,screen_height*8
       jl   get_map_char_vert_1
       li   r1,:0000000000001111
       rt
get_map_char_vert_1:
       s    @scroll_offset_pixels,r1
       ai   r1,(map_height_h-screen_height)*8
       sla  r1,2                       ; Char offset
       mov  r1,r2
       andi r1,>03e0
       sla  r2,1
       andi r2,>0800
       ai   r2,vmap0
       a    r2,r1
       srl  r0,11                      ; X
       a    r1,r0
       li   r2,TCHARS_V
get_map_char_3:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM read address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb *r14,r1                    ; Read byte from VDP RAM
       srl  r1,8                       ; To LSB
       sla  r1,1                       ; To word
       a    r2,r1                      ; Add transition chars table address
       mov  *r1,r1                     ; Get from/to chars
       srl  r1,8                       ; To LSB
       sla  r1,1                       ; To word
       mov  @char_props_table(r1),r1   ; Get properties
       rt
*// get_map_char

***************************************************************
*
* Remove meta tile from map
*
* r0: VDP address of a character in the metatile to remove
*
remove_meta_tile:
       .proc
       abs  @vertical
       jne  remove_meta_tile_1
       andi r0,>3efe                   ; Adjust to metatile
       dec  r0
       bl   @vwad
       clr  *r15
       clr  *r15
       clr  *r15
       ai   r0,map_width
       bl   @vwad
       clr  *r15
       clr  *r15
       clr  *r15
       jmp  remove_meta_tile_2
remove_meta_tile_1:
       andi r0,>2fde                   ; Adjust to metatile
       bl   @vwad
       clr  *r15
       clr  *r15
       ai   r0,map_width_h
       bl   @vwad
       clr  *r15
       clr  *r15
       ai   r0,map_width_h
       bl   @vwad
       clr  *r15
       clr  *r15
remove_meta_tile_2:
       .endproc
*// remove_meta_tile

***************************************************************
*
* Replace meta tile in map
*
* r0: VDP address of a character in the metatile to replace
* r1: CPU RAM address of replacement characters
*
replace_meta_tile:
       .proc
       andi r0,>3efe                   ; Adjust to metatile
       dec  r0
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       ai   r0,>100
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       .endproc
*// replace_meta_tile

***************************************************************
*
* Draw stars into buffer
*
* r8: row number on screen
* r9: full screen flag
*
draw_stars:
       mov  @scroll_offset_pixels,r0
       mov  r0,r2
       srl  r2,4                       ; Scroll offset/half speed
       mov  r8,r3
       dect r3                         ; Adjust for ceiling
       sla  r3,1
       a    @star_x(r3),r2             ; Add 'random' x position for row
       a    r9,r2
       andi r2,31
       neg  r2
       ai   r2,31                      ; 31-x
       xor  r9,r0
       andi r0,8                       ; Test bit for determining character
       jne  draw_stars_1
       li   r0,chr_star_1*256
       jmp  draw_stars_2
draw_stars_1:
       li   r0,chr_star_2*256
draw_stars_2:
       li   r4,3
draw_stars_3:
       movb @buffer(r2),r3
       jne  draw_stars_4
       movb r0,@buffer(r2)
draw_stars_4:
       ai   r2,11
       andi r2,31
       dec  r4
       jne  draw_stars_3
draw_stars_5:
       rt
star_x:
       data 25, 10, 6, 23, 15, 22, 3, 9, 14, 2, 29, 7, 11, 8, 31, 13    ; 1, 27, 4, 12
*// draw_stars

***************************************************************
*
* Scroll patterns horizontally and upload to VDP
*
scroll_patterns:
       .proc
       li   r4,TCHARS                  ; Pointer to from/to pattern numbers
*      Pattern loop
       clr  r2                         ; Pattern counter
scroll_patterns_1:
*      Scroll offset loop
       clr  r3                         ; Horizontal scroll offset (0-7)
scroll_patterns_2:
       mov  *r4,r5                     ; Get from and to pattern numbers
       jlt  scroll_patterns_5          ; >ff = unused
       mov  r5,r6                      ; Copy
       andi r5,>ff00                   ; Isolate
       swpb r5                         ; To LSB
       mov  r5,r8                      ; Copy
       sla  r5,3                       ; Multiply by 8
       ai   r5,pat0                    ; Address of from pattern
       sla  r8,1                       ; To word offset
       mov  @char_props_table(r8),r9   ; Check for vertical scrolling
       coc  @char_vert_scroll,r9
       jne  !
       mov  r5,r0
       li   r1,buffer
       bl   @copy_char_to_buffer
       li   r5,buffer
       a    r3,r5                      ; Add scroll offset
!      andi r6,>00ff                   ; Isolate
       mov  r6,r8                      ; Copy
       sla  r6,3                       ; Multiply by 8
       ai   r6,pat0                    ; Address of to pattern
       sla  r8,1                       ; To word offset
       mov  @char_props_table(r8),r9   ; Check for vertical scrolling
       coc  @char_vert_scroll,r9
       jne  !
       mov  r6,r0
       li   r1,buffer+16
       bl   @copy_char_to_buffer
       li   r6,buffer+16
       a    r3,r6                      ; Add scroll offset
*      Write address
!      mov  r2,r0                      ; Pattern number
       sla  r0,3                       ; Multiply by 8
       mov  r3,r1                      ; Scroll offset
       sla  r1,11                      ; Multiply by >800
       a    r1,r0                      ; Add to pattern offset
       bl   @vwad                      ; Setup write address
*      Row loop
       li   r7,8                       ; Row counter
scroll_patterns_3:
       movb *r5+,r1                    ; Get from byte
       movb *r6+,@r1lb                 ; Get to byte
       mov  r3,r0                      ; Get scroll offset
       jeq  scroll_patterns_4          ; Skip shift if zero
       sla  r1,0
scroll_patterns_4:
       movb r1,*r15                    ; Send to VDP
*      Next row
       dec  r7
       jne  scroll_patterns_3
*      Next scroll offset
       inc  r3
       ci   r3,8
       jlt  scroll_patterns_2
*      Next pattern
scroll_patterns_5:
       bl   @speak                     ; Speak if needed
       inct r4
       inc  r2
       c    r2,@TCHNUM                      ;
       jlt  scroll_patterns_1
       .endproc
*// scroll_patterns

***************************************************************
*
* Scroll star patterns and upload to VDP
*
scroll_star_patterns:
       .proc
       li   r1,>0100
       li   r5,4
       li   r0,8*chr_star_1+ptrntb
       bl   @scroll_star_pattern
       li   r0,8*chr_star_2+ptrntb
       bl   @scroll_star_pattern
       .endproc
scroll_star_pattern:
       .proc
       li   r2,4
scroll_star_pattern_1:
       li   r3,2
scroll_star_pattern_2:
       bl   @vwad
       mov  r5,r4
       jeq  scroll_star_pattern_4
scroll_star_pattern_3:
       clr  *r15
       dec  r4
       jne  scroll_star_pattern_3
scroll_star_pattern_4:
       movb r1,*r15
       li   r4,7
       s    r5,r4
       jeq  scroll_star_pattern_6
scroll_star_pattern_5:
       clr  *r15
       dec  r4
       jne  scroll_star_pattern_5
scroll_star_pattern_6:
       ai   r0,>800
       dec  r3
       jne  scroll_star_pattern_2
       abs  @vertical
       jne  scroll_star_pattern_7
       sla  r1,1
       jmp  scroll_star_pattern_8
scroll_star_pattern_7:
       inc  r5
       andi r5,7
scroll_star_pattern_8:
       dec  r2
       jne  scroll_star_pattern_1
       .endproc
*// scroll_star_patterns

*********************************************************************
*
* Copy char pattern to buffer twice
*
* r0: source
* r1: dest
*
copy_char_to_buffer:
       li   r9,8
copy_char_to_buffer_1:
       movb *r0,@8(r1)
       movb *r0+,*r1+
       dec  r9
       jne  copy_char_to_buffer_1
       rt
*// copy_char_to_buffer

*********************************************************************
*
* Read character set from GROM
*
read_grom_chars:
       .proc
       li   r0,ptrntb+>300
       li   r3,8
read_grom_chars_1:
       bl   @vwad
       li   r4,charset
       li   r5,32
read_grom_chars_2:
       clr  r1
       movb *r4+,@r1lb
       ai   r1,-32
       mov  r1,r6
       sla  r1,3
       s    r6,r1
       ai   r1,1716
       movb r1,@grmwa
       movb @r1lb,@grmwa
       clr  *r15                       ; Top line
       li   r2,4
read_grom_chars_3:
       movb @grmrd,r1
       srl  r1,1
       movb r1,*r15
       dec  r2
       jne  read_grom_chars_3
       li   r2,3
read_grom_chars_4:
       movb @grmrd,*r15
       dec  r2
       jne  read_grom_chars_4
       dec  r5
       jne  read_grom_chars_2
       ai   r0,>800
       dec  r3
       jne  read_grom_chars_1
       .endproc
*// read_grom_chars

*********************************************************************************
*
* Display text to both name table buffers (slow)
*
* r0: Screen offset
* r1: Pointer to zero terminated ascii text
*
* Modifies r0-r6
*
display_message:
       li   r0,21*32+6
display_text:
       .proc
       ai   r0,nametb
       bl   @vwad
       li   r2,buffer
display_text_0:
       movb *r1+,r4
       jeq  display_text_4
       li   r5,charset
       clr  r6
display_text_1:
       cb   r4,*r5+
       jeq  display_text_2
       inc  r6
       ci   r6,32
       jlt  display_text_1
       li   r6,chr_qst_mark
       jmp  display_text_3
display_text_2:
       ai   r6,96
display_text_3:
       swpb r6
       movb r6,*r15
       movb r6,*r2+
       jmp  display_text_0
*      2nd name table buffer
display_text_4:
       ai   r0,namet2-nametb
       li   r1,buffer
       ai   r2,-buffer
       bl   @vmbw
       .endproc
*// display_text

*********************************************************************
*
* Display decimal number
* VDP address must already be set up.
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       ai   r0,nametb
       mov  r0,r4
       bl   @vwad
       li   r5,buffer
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       ai   r0,chr_zero
       swpb r0
       movb r0,*r15
       movb r0,*r5+
       dec  r2
       jne  display_decimal_1
       ai   r1,chr_zero
       swpb r1
       movb r1,*r15
       movb r1,*r5+
*      2nd name table buffer
       mov  r4,r0
       ai   r0,namet2-nametb
       li   r1,buffer
       mov  r5,r2
       ai   r2,-buffer
       bl   @vmbw
       .endproc
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// display_decimal

***************************************************************
*
* Copy sprite patterns to VDP RAM
*
upload_sprite_patterns:
       .proc
       li   r0,sprptb+>400
       li   r1,SPR0
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,sprptb+>400+(n_sprite_patterns*32)
       clr  r1
       li   r2,(32-n_sprite_patterns)*32
       bl   @vsmw
       .endproc
*// upload_sprite_patterns

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Colors
       clr  @vertical
       bl   @set_colors
*      Return
       .endproc
*      VDP registers
vdp_registers:
       byte >00                        ; Graphics I mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte colrtb/>40                 ; Color table
       byte ptrntb/>800                ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

***************************************************************
*
* Copy row from VDP to buffer
* r0: source
*
set_colors:
       .proc
       li   r0,colrtb
       li   r1,>f100
       li   r2,32
       bl   @vsmw
       li   r0,colrtb
       abs  @vertical
       jne  set_colors_1
       li   r1,CLRSET
       mov  @CLRNUM,r2
       jmp  set_colors_2
set_colors_1:
       li   r1,CLRSET_V
       mov  @CLRNUM_V,r2
set_colors_2:
       bl   @vmbw
       .endproc

***************************************************************
*
* Copy row from VDP to buffer
* r0: source
*
copy_row_to_buffer:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r4,buffer
       li   r2,buffer_size/4
copy_rows_to_buffer_1:
       movb *r14,*r4+
       movb *r14,*r4+
       movb *r14,*r4+
       movb *r14,*r4+
       dec  r2
       jne  copy_rows_to_buffer_1
       rt
*// copy_row_to_buffer

***************************************************************
*
* Copy row from buffer to VDP
* r1: destination
*
copy_row_to_vdp:
       swpb r1
       movb r1,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r1
       ori  r1,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r1,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r4,buffer
       li   r2,buffer_size/4
copy_row_to_vdp_1:
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       dec  r2
       jne  copy_row_to_vdp_1
       rt
*// copy_row_to_vdp

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0:  Read address in VDP RAM
* R1:  MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb *r14,r1                    ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r15                    ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM read address
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
vmbr_1:
       movb *r14,*r1+                  ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************************
*
* Speech status read routine code, must be copied to scratchpad
*
speech_status_code:
       movb @spchrd,r1
       rt
speech_status_code_end
*// speech_status_code

*********************************************************************
*
* Data
*
map_row_table:
       data vmap0,vmap0+>100,vmap0+>200,vmap0+>300
       data vmap1,vmap1+>100,vmap1+>200,vmap1+>300
       data vmap2,vmap2+>100,vmap2+>200,vmap2+>300
       data vmap3,vmap3+>100,vmap3+>200,vmap3+>300
floor_ceil_table:
       data namet2+>0000,namet2+>0008,namet2+>0010,namet2+>0018
       data namet2+>0020,namet2+>0028,namet2+>0030,namet2+>0038
       data namet2+>0240,namet2+>0248,namet2+>0250,namet2+>0258
       data namet2+>0260,namet2+>0268,namet2+>0270,namet2+>0278
       data nametb+>0000,nametb+>0008,nametb+>0010,nametb+>0018
       data nametb+>0020,nametb+>0028,nametb+>0030,nametb+>0038
       data nametb+>0240,nametb+>0248,nametb+>0250,nametb+>0258
       data nametb+>0260,nametb+>0268,nametb+>0270,nametb+>0278
animation_roll:
       byte >80,4
       byte >88,4
       byte >80,4
       byte >90,4
       byte >80,0
animation_land:
       byte >90,2
       byte >98,2
       byte >a0,2
       byte >a8,2
       byte >a0,2
       byte >98,2
       byte >90,2
       byte >80,0
animation_die:
       byte >80,6
       byte >90,6
       byte >98,6
       byte >a0,6
       byte >a8,6
       byte >b0,6
       byte >b8,6
       byte >c0,6
       byte >c4,6
       byte >c8,0
sprite_100_pt:
       byte >d0,>0f
sprite_50_pt:
       byte >d4,>0e
enemy_lists:
       data enemy_list_0               ; 0
       data enemy_list_0               ; 1
       data enemy_list_0               ; 2
       data enemy_list_0               ; 3
       data enemy_list_0               ; 4
       data enemy_list_0               ; 5
       data enemy_list_1               ; 6 vertical
       data enemy_list_2               ; 7
       data enemy_list_3               ; 8
enemy_list_0:
       data -1
enemy_list_1:
       data >300,-1
enemy_list_2:
       data >300,>600,-1
enemy_list_3:
       data >200,>400,>600,-1
level_vertical:
       byte 0,0,0,0,0,0,1,0,0
level_names:
       data txt_title
       data txt_level_1
       data txt_level_2
       data txt_level_3
       data txt_level_4
       data txt_level_5
       data txt_level_6
       data txt_level_7
       data txt_level_8
txt_stats:
       text "SCORE:000000 LEVEL:00 LIVES:00"
       byte 0
txt_title:
       text "  OBSTACLE COURSE  "
       byte 0
txt_copyright:
       text "  COPYRIGHT 2019   "
       byte 0
txt_credits:
       text " RASMUS MOUSTGAARD "
       byte 0
txt_fire_to_begin:
       text "PRESS FIRE TO BEGIN"
       byte 0
txt_level_completed:
       text "  LEVEL COMPLETED  "
       byte 0
txt_game_over:
       text "     GAME OVER     "
       byte 0
txt_speech_on:
       text "     SPEECH ON     "
       byte 0
txt_speech_off:
       text "     SPEECH OFF    "
       byte 0
       even
txt_level_1:
       text "  ONE SMALL LEAP   "
       byte 0
txt_level_2:
       text "  TRAMPOLINE FUN   "
       byte 0
txt_level_3:
       text "   LONG BOUNCES    "
       byte 0
txt_level_4:
       text "     SPEED RUN     "
       byte 0
txt_level_5:
       text "    THE BRIDGE     "
       byte 0
txt_level_6:
       text "   THE MOUNTAIN    "
       byte 0
txt_level_7:
       text "      LEVEL 7      "
       byte 0
txt_level_8:
       text "      LEVEL 8      "
       byte 0
keys_keyboard:
       data KEY_SP, KEY_S, KEY_D
keys_joystick:
       data JOY_FI, JOY_LT, JOY_RT

*********************************************************************
*
* Includes
*
       copy "sound-fx-routines.a99"
       copy "charset.a99"
map_chars:
       copy "map-chars.a99"
       copy "sprite-patterns.a99"

       copy "vertical.a99"


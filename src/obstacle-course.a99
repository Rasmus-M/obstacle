*********************************************************************
*
* Obstacles course
* For the TI-99/4A home computer
*
* January 2019
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
nametb equ  >0400                      ; Name table base 1
spratb equ  >0700                      ; Sprite attribute table base
colrtb equ  >0780                      ; Color table base
ptrnt2 equ  >0800                      ; Patterns
namet2 equ  >0c00                      ; Name table base 2
ptrnt3 equ  >1000                      ; Patterns
sprptb equ  >1000                      ; Sprite pattern table base (only from >1400, 32 patterns)
ptrnt4 equ  >1800                      ; Patterns
freev1 equ  >1c00                      ; 1k free
ptrnt5 equ  >2000                      ; Patterns
vmap0  equ  >2400                      ; Map
ptrnt6 equ  >2800                      ; Patterns
vmap1  equ  >2c00                      ; Map
ptrnt7 equ  >3000                      ; Patterns
vmap2  equ  >3400                      ; Map
ptrnt8 equ  >3800                      ; Patterns
vmap3  equ  >3c00                      ; Map

**
* Constants
*
bank_0:
       equ  >6002
bank_1:
       equ  >6000
scroll_speed_normal:
       equ  >0100
scroll_speed_slow:
       equ  >0080
map_width:
       equ  256
map_height:
       equ  16
map_size:
       equ  map_width*map_height
screen_width:
       equ  32
buffer_size:
       equ  32
log_2_buffer_size:
       equ  5
n_sprite_patterns:
       equ  19
chr_space:
       equ  96
chr_zero:
       equ  97
chr_qst_mark:
       equ  chr_space
n_lives:
       equ  3
n_levels:
       equ  4
start_level:
       equ  1

* Sound channel structure
snd_channel_addr:
       equ  0
snd_channel_duration:
       equ  2
snd_channel_attn:
       equ  3
snd_channel_freq:
       equ  4
snd_channel_size:
       equ  6

* Sound track structure
snd_track_channel:                     ; Channel to play track in, zero of track inactive
       equ  0
snd_track_location:                    ; Location in track, points to sequence pointer or command
       equ  2
snd_track_seq_location:                ; Location in active sequecne
       equ  4
snd_track_duration_count:              ; Node (within sequence) duration counter
       equ  6
snd_track_repeat_count:                ; Repeat count for track loops
       equ  7
snd_track_size:
       equ  8

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>18                  ; Start of pad variables

**
* PAD variables
*
level:
       equ  padvar
mod_level:
       equ  level+2
lives:
       equ  mod_level+2
score:
       equ  lives+2
disp_score:
       equ  score+2
status:
       equ  disp_score+2
demo:
       equ  status+2
frame:
       equ  demo+2
vdp_status:
       equ  frame+2
scroll_x:                              ; Scroll offset in FP 12.4
       equ  vdp_status+2
scroll_x_pixels:                       ; Scroll offset in pixels
       equ  scroll_x+2
scroll_vx:                             ; FP 8.8
       equ  scroll_x_pixels+2
ball_x:                                ; FP 8.8
       equ  scroll_vx+2
ball_vx:                               ; FP 8.8
       equ  ball_x+2
ball_vx_last:                          ; FP 8.8
       equ  ball_vx+2
ball_y:                                ; FP 8.8
       equ  ball_vx_last+2
ball_vy:                               ; FP 8.8
       equ  ball_y+2
ball_ay:                               ; FP 8.8
       equ  ball_vy+2
ball_pattern_color:
       equ  ball_ay+2
ball_pattern_color_offset:
       equ  ball_pattern_color+2
ball_animation_ptr:
       equ  ball_pattern_color_offset+2
ball_animation_count:
       equ  ball_animation_ptr+2
ball_rebounce:
       equ  ball_animation_count+2
enemy_x:
       equ  ball_rebounce+2
enemy_vx:
       equ  enemy_x+2
enemy_y:
       equ  enemy_vx+2
enemy_vy:
       equ  enemy_y+2
enemy_list_ptr:
       equ  enemy_vy+2
points_sprite_y:
       equ  enemy_list_ptr+2
points_sprite_x:
       equ  points_sprite_y+2
points_sprite_pattern_color:
       equ  points_sprite_x+2
snd_channel_1:
       equ  points_sprite_pattern_color+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
module_speed:
       equ  snd_track_3+snd_track_size
buffer:
       equ  module_speed+2
pad_max:
       equ  buffer+buffer_size

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

       .defm push
       mov  #1,*r10+
       .endm

       .defm pop
       dect r10
       mov  *r10,#1
       .endm

       .defm peek
       mov  @-2(r10),#1
       .endm

***************************************************************
*
* Cartridge all banks
*
       aorg >6000
       bank all

***************************************************************
*
* Cartridge header
*
       byte >AA,1,1,0
       data 0
       data program
       data 0,0
program:
       data 0
       data main
       byte 15
       text 'OBSTACLE COURSE'


*********************************************************************
*
* Trampoline code for executing bank 0 routine
*
* r13: address of bank 0 routine
*
bank_0_exec:
       .proc
       seto @bank_0
       bl   *r13
       seto @bank_1
       .endproc
*// bank_0_exec

*********************************************************************
*
* Trampoline code for executing bank 1 routine
*
* r13: address of bank 1 routine
*
bank_1_exec:
       .proc
       seto @bank_1
       bl   *r13
       seto @bank_0
       .endproc
*// bank_1_exec

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vmbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,*r15                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*r15                    ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* Program stub for switching to bank 0
*
main:
       seto @bank_0

***************************************************************
*
* Cartridge banks
*
       copy "bank0.a99"
       copy "bank1.a99"

       end

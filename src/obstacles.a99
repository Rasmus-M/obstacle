*********************************************************************
*
* Obstacles course
* For the TI-99/4A home computer
*
* January 2019
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400
grmrd  equ  >9800                      ; GROM read data (GROM base)
grmra  equ  >9802                      ; GROM read address+1
grmwd  equ  >9C00
grmwa  equ  >9C02

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
nametb equ  >0400                      ; Name table base 1
spratb equ  >0700                      ; Sprite attribute table base
colrtb equ  >0780                      ; Color table base
ptrnt2 equ  >0800                      ; Patterns
namet2 equ  >0c00                      ; Name table base 2
ptrnt3 equ  >1000                      ; Patterns
sprptb equ  >1000                      ; Sprite pattern table base (only from >1400, 32 patterns)
ptrnt4 equ  >1800                      ; Patterns
freev1 equ  >1c00                      ; 1k free
ptrnt5 equ  >2000                      ; Patterns
vmap0  equ  >2400                      ; Map
ptrnt6 equ  >2800                      ; Patterns
vmap1  equ  >2c00                      ; Map
ptrnt7 equ  >3000                      ; Patterns
vmap2  equ  >3400                      ; Map
ptrnt8 equ  >3800                      ; Patterns
vmap3  equ  >3c00                      ; Map

**
* Constants
*
map_width:
       equ  256
map_height:
       equ  16
map_size:
       equ  map_width*map_height
screen_width:
       equ  32
buffer_size:
       equ  32
log_2_buffer_size:
       equ  5
chr_qst_mark:
       equ  112

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables

**
* PAD variables
*
scroll_x:
       equ  padvar
ball_x:
       equ  scroll_x+2
ball_vx:
       equ  ball_x+2
ball_y:
       equ  ball_vx+2
ball_vy:
       equ  ball_y+2
ball_ay:
       equ  ball_vy+2
ball_pattern:
       equ  ball_ay+2
ball_jumping:
       equ  ball_pattern+2
ball_animation_ptr:
       equ  ball_jumping+2
buffer:
       equ  ball_animation_ptr+2
pad_max:
       equ  buffer+buffer_size

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

       .defm push
       mov  #1,*r10+
       .endm

       .defm pop
       dect r10
       mov  *r10,#1
       .endm

       .defm peek
       mov  @-2(r10),#1
       .endm

***************************************************************
*
       def  main
       aorg >6000

***************************************************************
*
* Cartridge header
*
header:
       byte >AA,1,1,0
       data 0
       data program
       data 0,0
program:
       data 0
       data main
       byte 16
       text 'OBSTACLES COURSE'

***************************************************************
*
* Main program
*
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r14,vdprd                  ; Do not change
       li   r15,vdpwd                  ; Do not change
       bl   @graphics_mode
       bl   @init_game
loop:
       bl   @vsync
       bl   @update_vdp_regs
       bl   @update_sprites
       bl   @move_ball
       bl   @update_partial_name_table
       bl   @player_input
       bl   @check_quit
       mov  @scroll_x,r0
       inc  r0
       andi r0,>07ff
       mov  r0,@scroll_x
       jmp  loop

***************************************************************
*
* Initialize game
*
init_game:
       .proc
       bl   @copy_map_to_vdp
       bl   @scroll_patterns
       bl   @read_grom_chars
       clr  @scroll_x
       bl   @update_full_name_table
       li   r0,23*32+8
       li   r1,title
       bl   @display_text
*      Sprite patterns
       li   r0,sprptb+>400
       li   r1,SPR0
       li   r2,8*32
       bl   @vmbw
*      Ball
       li   r0,>8000
       mov  r0,@ball_y
       clr  @ball_vy
       li   r0,>0018
       mov  r0,@ball_ay
       li   r0,>4000
       mov  r0,@ball_x
       li   r0,>800e
       mov  r0,@ball_pattern
       clr  @ball_jumping
       clr  @ball_animation_ptr
       .endproc
*// init_game

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,r12
       rt
*// vsync

***************************************************************
*
* Update VDP registers
*
update_vdp_regs:
       .proc
*      Set pattern table
       mov  @scroll_x,r0
       andi r0,>0007
       ori  r0,>0400
       bl   @vwtr
*      Set name table
       mov  @scroll_x,r0
       andi r0,>0008
       srl  r0,2
       inc  r0
       ori  r0,>0200
       bl   @vwtr
       .endproc
*// update_vdp_regs

***************************************************************
*
* Update sprites
*
update_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
       mov  @ball_y,r0
       ai   r0,->0100
       mov  @ball_pattern,r1
       movb r0,*r15
       movb @ball_x,*r15
       movb r1,*r15
       movb @r1lb,*r15
       movb r0,*r15
       movb @ball_x,*r15
       ai   r1,>1001
       movb r1,*r15
       movb @r1lb,*r15
       .endproc
*// update_sprites

***************************************************************
*
* Move ball
*
move_ball:
       .proc
*      Check char in front of ball
       li   r0,>1000
       li   r1,>0c00
       bl   @get_map_char
       movb r1,r1
       jeq  move_ball_6
       li   r0,->0100
       jmp  move_ball_7
move_ball_6:
       mov  @ball_vx,r0
move_ball_7:
       a    r0,@ball_x
*      Check for animation
       mov  @ball_animation_ptr,r0
       jne  move_ball_3
*      Check y velocity
       mov  @ball_vy,r0
       jlt  move_ball_1                ; Moving up
       li   r0,>800e
       mov  r0,@ball_pattern
*      Check char under ball
move_ball_0:
       li   r0,>0a00
       li   r1,>1000
       bl   @get_map_char
       movb r1,r1
       jne  move_ball_2
*      Move with acceleration
move_ball_1:
       a    @ball_ay,@ball_vy
       a    @ball_vy,@ball_y
       jmp  move_ball_5
*      Hit the floor
move_ball_2:
       mov  @ball_vy,r0
       jeq  move_ball_5
       clr  @ball_jumping
       mov  @ball_y,r0
       andi r0,>f000
       mov  r0,@ball_y
       clr  @ball_vy
       li   r0,animation_land
       mov  r0,@ball_animation_ptr
       jmp  move_ball_5
*      Animate
move_ball_3:
       movb *r0+,r1
       jeq  move_ball_4
       movb r1,@ball_pattern
       mov  r0,@ball_animation_ptr
       jmp  move_ball_5
move_ball_4:
       clr  @ball_animation_ptr
move_ball_5:
       .endproc
animation_land:
       byte >84,>84,>84
       byte >88,>88,>88
       byte >84,>84,>84
       byte >80,>00,>00
*// move_ball

***************************************************************
*
* Update 1/8 name table
*
update_partial_name_table:
       .proc
       mov  @scroll_x,r6
*      Ceiling and floor
       mov  r6,r1
       andi r1,>000f
       sla  r1,1
       mov  @floor_ceil_table(r1),r0
       bl   @vwad
       mov  r6,r1
       andi r1,>0006
       ai   r1,CEIL
       mov  *r1,r2
       mov  r6,r1
       andi r1,>0008
       jne  update_partial_name_table_0
       swpb r2
update_partial_name_table_0:
       movb r2,r0
       swpb r2
       movb r2,r1
       li   r2,4
update_partial_name_table_1:
       movb r0,*r15
       movb r1,*r15
       movb r0,*r15
       movb r1,*r15
       dec  r2
       jne  update_partial_name_table_1
*      Middle rows
       andi r6,>0007
       sla  r6,1
       li   r7,2
       bl   @copy_map_rows_from_vdp
       .endproc
*// update_partial_name_table

***************************************************************
*
* Read player input
*
player_input:
       .proc
       li   r0,JOY_FI
       bl   @check_key
       jeq  player_input_1
       bl   @jump
player_input_1:
       clr  r1
       tb   1
       jeq  player_input_2
       li   r1,->0180
player_input_2:
       tb   2
       jeq  player_input_3
       li   r1,>0080
player_input_3:
       mov  r1,@ball_vx
       .endproc
*// player_input

*********************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       rt
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

***************************************************************
*
* Copy map rows from VDP RAM
*
* r6: Start row number to copy
* r7: Number of rows to copy
*
copy_map_rows_from_vdp:
       .proc
*      Dest
       mov  @scroll_x,r1               ; Calculate current name table address
       inv  r1
       andi r1,>0008
       sla  r1,8
       ai   r1,nametb
       mov  r6,r0                      ; Row offset
       inct r0                         ; Two rows offset
       sla  r0,5
       a    r0,r1
*      Source
       mov  @scroll_x,r5               ; Column offset
       srl  r5,3
       inc  r5                         ; Plus one
       andi r5,map_width-1             ; Wrap at 256 columns
       sla  r6,1                       ; Lookup table address
       ai   r6,map_row_table
copy_map_rows_from_vdp_1:
       mov  *r6+,r0                    ; Row start
       a    r5,r0                      ; Add column offset
       ci   r5,map_width-screen_width
       jh   copy_map_rows_from_vdp_2
*      Fast, non-wrapping
       li   r2,screen_width
       bl   @vdp_to_vdp_copy_fast      ; Copy row
       jmp  copy_map_rows_from_vdp_3
*      Slow, wrapping
copy_map_rows_from_vdp_2:
       li   r2,map_width
       s    r5,r2
       bl   @vdp_to_vdp_copy           ; Copy 1st part
       mov  r5,r2
       ai   r2,-(map_width-screen_width)
       dect r6
       mov  *r6+,r0
       bl   @vdp_to_vdp_copy           ; Copy 2nd part from beginning
copy_map_rows_from_vdp_3:
       dec  r7
       jne  copy_map_rows_from_vdp_1
       .endproc
*// copy_map_rows_from_vdp

***************************************************************
*
* Update full name table
*
update_full_name_table:
       .proc
*      Ceiling and floor
       li   r0,nametb
       li   r3,CEIL
       li   r4,2
update_full_name_table_0:
       bl   @vwad
       mov  *r3+,r1
       bl   @update_full_name_table_2
       mov  *r3+,r1
       bl   @update_full_name_table_2
       ai   r0,>0240
       dec  r4
       jne  update_full_name_table_0
*      Dest
       li   r1,nametb+>40
*      Source
       mov  @scroll_x,r5               ; Column offset
       srl  r5,3
       li   r6,map_row_table
*      Copy
       li   r7,map_height
update_full_name_table_1:
       mov  *r6+,r0                    ; Row start
       a    r5,r0                      ; Add column offset
       li   r2,screen_width
       bl   @vdp_to_vdp_copy_fast      ; Copy row
       dec  r7
       jne  update_full_name_table_1
       .endproc
update_full_name_table_2:
       li   r2,16
update_full_name_table_3:
       movb r1,*r15
       movb @r1lb,*r15
       dec  r2
       jne  update_full_name_table_3
       rt
*// update_full_name_table

***************************************************************
*
* Init jump
*
jump:
       .proc
       mov  @ball_jumping,r0
       jne  jump_1
       li   r0,->0280
       mov  r0,@ball_vy
       li   r0,>8c0e
       mov  r0,@ball_pattern
       seto @ball_jumping
jump_1:
       .endproc
*// jump

***************************************************************
*
* Get map char relative to ball
*
* r0: x offset in MSB
* r1: y offset in MSB
*
get_map_char:
       a    @ball_y,r1                 ; Add offset to y
       srl  r1,11                      ; To chars
       ci   r1,2                       ; Above map?
       jhe  get_map_char_1
       clr  r1                         ; Space
       rt
get_map_char_1:
       dect r1                         ; Adjust for ceiling
       ci   r1,map_height              ; Below map?
       jl   get_map_char_2
       li   r1,>0102                   ; Floor
       rt
get_map_char_2:
       a    @ball_x,r0                 ; Add offset to x
       srl  r0,8                       ; To pixels
       a    @scroll_x,r0               ; Add scroll offset
       srl  r0,3                       ; To chars
       andi r0,>00ff                   ; Wrap around
       sla  r1,1                       ; To word
       a    @map_row_table(r1),r0      ; Add row offset
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM read address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop                             ; Wait
       movb *r14,r1                    ; Read byte from VDP RAM
       srl  r1,8                       ; To LSB
       sla  r1,1                       ; To word
       mov  @TCHARS(r1),r1             ; Get from/to chars
       rt
*// get_map_char

***************************************************************
*
* Unpack and copy map to VDP RAM
*
copy_map_to_vdp:
       .proc
*      Upload
       li   r0,>2000
       li   r1,map1_lz4+11
       li   r2,map1_lz4_end-map1_lz4-19
       bl   @vmbw
*      Unpack
       li   r0,>2000
       li   r1,>1000
       li   r2,>2000+(map1_lz4_end-map1_lz4-19)
       bl   @unpack_lz4_from_to_vdp
*      Rearrange
       li   r0,>1000
       li   r1,vmap0
       li   r2,>400
       bl   @vdp_to_vdp_copy_fast
       li   r0,>1400
       li   r1,vmap1
       li   r2,>400
       bl   @vdp_to_vdp_copy_fast
       li   r0,>1800
       li   r1,vmap2
       li   r2,>400
       bl   @vdp_to_vdp_copy_fast
       li   r0,>1c00
       li   r1,vmap3
       li   r2,>400
       bl   @vdp_to_vdp_copy_fast
       .endproc
*// copy_map_to_vdp

***************************************************************
*
* Scroll patterns horizontally and upload to VDP
*
scroll_patterns:
       .proc
       li   r4,TCHARS                  ; Pointer to from/to pattern numbers
*      Pattern loop
       clr  r2                         ; Pattern counter
scroll_patterns_1:
*      Scroll offset loop
       clr  r3                         ; Horizontal scroll offset (0-7)
scroll_patterns_2:
       mov  *r4,r5                    ; Get from and to pattern numbers
       jlt  scroll_patterns_5
       mov  r5,r6
       andi r5,>ff00
       swpb r5
       sla  r5,3
       ai   r5,pat0                    ; Address of from pattern
       andi r6,>00ff
       sla  r6,3
       ai   r6,pat0                    ; Address of to pattern
*      Write address
       mov  r2,r0                      ; Pattern number
       sla  r0,3                       ; Multiply by 8
       mov  r3,r1                      ; Scroll offset
       sla  r1,11                      ; Multiply by >800
       a    r1,r0                      ; Add to pattern offset
       bl   @vwad                      ; Setup write address
*      Row loop
       li   r7,8                       ; Row counter
scroll_patterns_3:
       movb *r5+,r1                    ; Get from byte
       movb *r6+,@r1lb                 ; Get to byte
       mov  r3,r0                      ; Get scroll offset
       jeq  scroll_patterns_4          ; Skip shift if zero
       sla  r1,0
scroll_patterns_4:
       movb r1,*r15                    ; Send to VDP
*      Next row
       dec  r7
       jne  scroll_patterns_3
*      Next scroll offset
       inc  r3
       ci   r3,8
       jlt  scroll_patterns_2
*      Next pattern
scroll_patterns_5:
       inct r4
       inc  r2
       c    r2,@TCHNUM                      ;
       jlt  scroll_patterns_1
       .endproc
*// scroll_patterns

*********************************************************************
*
* Read character set from GROM
*
read_grom_chars:
       .proc
       li   r0,ptrntb+>300
       li   r3,8
read_grom_chars_1:
       bl   @vwad
       li   r4,charset
       li   r5,32
read_grom_chars_2:
       clr  r1
       movb *r4+,@r1lb
       ai   r1,-32
       mov  r1,r6
       sla  r1,3
       s    r6,r1
       ai   r1,1716
       movb r1,@grmwa
       movb @r1lb,@grmwa
       clr  *r15                       ; Top line
       li   r2,7
read_grom_chars_3:
       movb @grmrd,*r15
       dec  r2
       jne  read_grom_chars_3
       dec  r5
       jne  read_grom_chars_2
       ai   r0,>800
       dec  r3
       jne  read_grom_chars_1
       .endproc
*// read_grom_chars

*********************************************************************************
*
* Display text to both name table buffers (slow)
*
* r0: VDP offset
* r1: Points to zero terminated ascii text
*
display_text:
       .proc
       ai   r0,nametb
       bl   @vwad
       li   r2,buffer
display_text_0:
       movb *r1+,r4
       jeq  display_text_4
       li   r5,charset
       clr  r6
display_text_1:
       cb   r4,*r5+
       jeq  display_text_2
       inc  r6
       ci   r6,32
       jlt  display_text_1
       li   r6,chr_qst_mark
       jmp  display_text_3
display_text_2:
       ai   r6,96
display_text_3:
       swpb r6
       movb r6,*r15
       movb r6,*r2+
       jmp  display_text_0
*      2nd name table buffer
display_text_4:
       ai   r0,namet2-nametb
       li   r1,buffer
       ai   r2,-buffer
       bl   @vmbw
       .endproc
*// display_text

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vregs2
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Colors
       li   r0,colrtb
       li   r1,>f100
       li   r2,32
       bl   @vsmw
       li   r0,colrtb
       li   r1,CLRSET
       mov  @CLRNUM,r2
       bl   @vmbw
*      Sprite attributes
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Return
       .endproc
*      VDP registers
vregs2:
       byte >00                        ; Graphics I mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte colrtb/>40                 ; Color table
       byte ptrntb/>800                ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* VDP to VDP copy (slower)
*
* r0: Source address
* r1: Destination address
* r2: Number of bytes to copy
*
* Modifies r0-r4. On return r0 and r1 are incremented by r2 bytes.
*
vdp_to_vdp_copy:
       .push r5
       ori  r1,>4000                   ; Prepare write address
vdp_to_vdp_copy_1:
       li   r5,buffer_size
       c    r2,r5
       jhe  vdp_to_vdp_copy_2
       mov  r2,r5
vdp_to_vdp_copy_2:
*      Read block
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r4,buffer
       mov  r5,r3
vdp_to_vdp_copy_3:
       movb *r14,*r4+
       dec  r3
       jne  vdp_to_vdp_copy_3
*      Write block
       swpb r1
       movb r1,@vdpwa
       swpb r1
       movb r1,@vdpwa
       li   r4,buffer
       mov  r5,r3
vdp_to_vdp_copy_4:
       movb  *r4+,*r15
       dec  r3
       jne  vdp_to_vdp_copy_4
*      Next
       a    r5,r0
       a    r5,r1
       s    r5,r2
       jgt  vdp_to_vdp_copy_1
       .pop r5
       rt
*// vdp_to_vdp_copy

*********************************************************************
*
* VDP to VDP copy (fast)
*
* r0: Source address
* r1: Destination address
* r2: Number of bytes to copy (must be a multiple of buffer_size (32))
*
* Modifies r0-r4. On return r0 and r1 are incremented by r2 bytes.
*
vdp_to_vdp_copy_fast:
       ori  r1,>4000                   ; Prepare write address
       srl  r2,log_2_buffer_size
vdp_to_vdp_copy_fast_1:
*      Read block
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r3,buffer_size/4
       li   r4,buffer
vdp_to_vdp_copy_fast_2:
       movb *r14,*r4+
       movb *r14,*r4+
       movb *r14,*r4+
       movb *r14,*r4+
       dec  r3
       jne  vdp_to_vdp_copy_fast_2
*      Write block
       swpb r1
       movb r1,@vdpwa
       swpb r1
       movb r1,@vdpwa
       li   r3,buffer_size/4
       li   r4,buffer
vdp_to_vdp_copy_fast_3:
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       dec  r3
       jne  vdp_to_vdp_copy_fast_3
       ai   r0,buffer_size
       ai   r1,buffer_size
       dec  r2
       jne  vdp_to_vdp_copy_fast_1
       rt
*// vdp_to_vdp_copy_fast

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0:  Read address in VDP RAM
* R1:  MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb *r14,r1                    ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r15                    ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vmbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,*r15                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*r15                    ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM read address
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
vmbr_1:
       movb *r14,*r1+                  ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
hKEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* Data
*
map_row_table:
       data vmap0,vmap0+>100,vmap0+>200,vmap0+>300
       data vmap1,vmap1+>100,vmap1+>200,vmap1+>300
       data vmap2,vmap2+>100,vmap2+>200,vmap2+>300
       data vmap3,vmap3+>100,vmap3+>200,vmap3+>300
floor_ceil_table:
       data namet2+>0000,namet2+>0010,namet2+>0020,namet2+>0030
       data namet2+>0240,namet2+>0250,namet2+>0260,namet2+>0270
       data nametb+>0000,nametb+>0010,nametb+>0020,nametb+>0030
       data nametb+>0240,nametb+>0250,nametb+>0260,nametb+>0270

title:
       text "OBSTACLES COURSE"
       byte 0
       even

*********************************************************************
*
* Includes
*
       copy "unlz4FromToVdp.a99"
       copy "spritePatterns.a99"
       copy "charset.a99"
map1_chars:
       copy "map1-chars.a99"
map1_lz4:
       bcopy "map1.lz4"
map1_lz4_end

       end

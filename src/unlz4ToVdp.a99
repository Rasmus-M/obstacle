* LZ4 decompressor for 9900
* Ported by Tursi from LZ4 data decompressor for Apple II
* by Peter Ferrie (peter.ferrie@gmail.com)

* sample calling:
* LIMI 0                 ; make sure interrupts are off
* LI R0,VDPDESTADR		 * VDP destination address
* BL @SETVDPWRITE        ; you set VDP write address in your code
* LI R0,SRCADR			 * pack data source in CPU
* LI R2,SRCADR+PACKBYTES * end address in CPU
* BL @UNPACKLZ4FROMVDP	 * do it!

* unpacker variables, no need to change these
* for now we'll just use registers
src     equ 0
dst     equ 1
end     equ 2
a       equ 3
b       equ 4
count   equ 5
delta   equ 6
stacklz equ 7
return  equ 8

* unpacker entrypoint
* VDP write address must be set up
* r0 = src address
* r2 = end of packed data

unpack_lz4_to_vdp:
       mov  r11,return                 ; remember return address

parsetoken:
       movb *src+,a                    ; read a token byte
       movb a,b                        ; save it off for later
       srl  a,12                       ; make a counter out of the literal count MS nibble
       jeq  copymatches                ; if it's zero, go to the match copy

       bl   @buildcount                ; check for additional bytes of length
       bl   @docopy                    ; we know the src, dest, and count, so do it
       c    src,end                    ; see if we're done yet (only place src advances)
       jl   copymatches                ; skip over if not done and work on the back reference
    
done:
       b    *return                    ; back to caller

copymatches:
       movb *src+,delta                ; getsrc -> lsb (sadly it can be unaligned)
       swpb delta
       movb *src+,delta                ; getsrc -> msb - this gives us the offset
       mov  b,a                        ; get the token back
       andi a,>0f00                    ; get the reference count from the token
       srl  a,8                        ; make it a count
       bl   @buildcount                ; check for additional bytes of length
    
       ai   count,4                    ; reference length always adds 4 bytes
       mov  src,stacklz                ; save the current compressed source address
       mov  dst,src                    ; get the current destination pointer
       s    delta,src                  ; and subtract the delta
       bl   @docopy                    ; we have src, dest, and count, do the copy
       mov  stacklz,src                ; restore the compressed pointer
       jmp  parsetoken                 ; and go parse the next token

docopy:
       movb *src+,@vdpwd               ; copy one byte
       inc  dst                        ; update dst since writing to VDP won't do it
       dec  count                      ; count down
       jne  docopy                     ; loop if not done
       rt                              ; return if we are

* start with a count in 'a', build an actual count in 'count'
buildcount:
       mov  a,count                    ; store the count
       ci   count,15                   ; if it's not 15, we're done
       jne  bc2
bc1:
       movb *src+,a                    ; get the next byte
       srl  a,8                        ; make it a count
       a    a,count                    ; add it in
       ci   a,255                      ; check if there are more
       jeq  bc1                        ; there are
bc2:
       rt                              ; else we're done
